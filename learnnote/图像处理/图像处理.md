###python环境安装openc
pip install opencv-python

###关于jpg和png
jpg是有损压缩，png是无损压缩
png有透明度属性
jpg的数值越小，压缩比越高，压缩范围为：0-100，例如为0
png的数值越小，压缩比越小，压缩范围为:0-9

img = cv2.imread('C:/Users/nanfengchuiyeluo/Desktop/sucai1.jpg',1)
参数：1窗体的名称 2展示的内容
cv2.imwrite('C:/Users/nanfengchuiyeluo/Desktop/sucai2.jpg',img,[cv2.IMWRITE_JPEG_QUALITY,==50==])

###关于图片的一些知识点
1.像素：放大以后的一个个小方格
2.RGB：每个颜色都是由三种颜色不同百分比形成的，红，绿，蓝
3.颜色深度：8bit 0-255 所以共有256^3^种
4.图片的宽和高：例640\*480 长有640个像素点，宽有480个像素点
5.图片大小：1.14M = 720\*480\*3\*8bit/8(B) = 1.14
6.对于png图片，每个像素点除RGB三个颜色分量外，还有alpha通道，描绘透明度
7.除去RGB还有BGR：蓝色排在前，每个颜色称为一个颜色通道

###图像处理/255.0和/127.5-1
第一种对图像进行归一化，范围[0，1]
第二种也是对图像进行归一化，范围为[-1，1]

###Haar特征分类器
是一个XML文件，该文件会描述人脸的Haar特征值

###detectMultiScale(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]])
返回一系列矩形框（坐标，和框长宽），确定一个点然后加上长宽
image表示的是要检测的输入图像
objects表示检测到的人脸目标序列
scaleFactor表示每次图像尺寸减小的比例
minNeighbors表示每一个目标至少要被检测到3次才算是真的目标(因为周围的像素和不同的窗口大小都可以检测到人脸),
minSize为目标的最小尺寸
maxSize为目标的最大尺寸


###cv2.flip(src, flipCode[, dst])
图像翻转进行数据增强
|flipCode  |  Anno     |
|:--------:|:---------:|
|1         |水平翻转    |
|0         |垂直翻转    |
|-1        |水平垂直翻转|     

###reshape(a, newshape, order='C')
```
[[[ 1  2]
  [ 3  4]
  [ 5  6]]
 
 [[ 7  8]
  [ 9 10]
  [11 12]]]

```
  shape=(2,3,2)
  第一维有2个元素，第二维有三个元素，第三维有2个元素（看中括号）
  
c=np.reshape(a,(2,2,-1))
 newshape参数用数组表示，以c为例，数组(2,2,-1)就是c的形状，一共有三阶，第三个数字是reshape后数组a中最小单元中元素个数，在这里是3，如果是-1则表示可以自动推测出。

###将两个嵌套for循环写成一个列表生成式
如，有一个嵌套列表，a=[[1,2],[3,4],[5,6]]，要提取列表里的每一个元素
用for循环处理：
```
for i in a:
    for j in i:
        print(j)
```
列表生成式：
```
b=[j for i in a for j in i]#注意两个for的顺序 
print(b)
>>> b
[1, 2, 3, 4, 5, 6]
```
###python sys.argv
其实就是一个数组，argv[0]:表示代码本身的绝对路径，剩下的为参数

###cv2.cvtColor
转换图片的颜色空间

###图片的读取与展示分为4步
**(1)**：文件的读取
**(2)**：封装格式的解析
**(3)**：数据解析
**(4)**：数据加载

###检测到脸，画框：Imgproc.rectangle(imgGray, facesArray[i].tl(), facesArray[i].br(), new Scalar(0, 255, 0, 255), 3)
facesArray[i].tl()：返回矩形框左上顶点
facesArray[i].br()：返回矩形框右下顶点
thickness代表画线的厚度，默认为1

###Scalar(0,255,0，125)
代表BGR:此为绿色，alpha通道值为125为 （255为不透明，0为全透明会忽略所有的 RGB 颜色）

###img.shape获取形状
(354,236,3)代表高，宽，模式

###为什么opencv读取图片格式是BGR
当时主流摄像头制造商和软件供应商采集图片的通道顺序是BGR，并且对于图片，位图BMP是最简单的，它的格式是BGR


###最近临域插值
例如：
src 10 * 20 dst 5 * 10
dst <-src
(1,2) <- (2,4)
dst x 1 -> src x 2 newx
newx = x*(src行/目标行) 
newx = 1*(10/5) = 2 
即：$$\cfrac{newx(源x)}{x(目标x)}=\cfrac{src行}{目标行} $$
(x为目标的x，newx代表原图像的x)
newy = y*(src列/目标列) newy =2*(20/10) = 4 
(y为目标的y)
**这里称为线性变换**
若计算出的值为小数，如12.3 = 12，**取离这个数最近的整数，即最近邻域插值**

###双线性插值
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/图片缩放.jpg)

假设通过线性变换求得的点坐标是（15.2，22.3）
A1 = 20%*上 +80%*下 (离上边点距离0.2，下边点距离0.8)
B1 = 30%*左 +70%右
最终点 = A1 * 30% + A2 * 70%
最终点 = B1 * 20% + B2 * 80%


###下载谷歌图片
**1.安装**
```
pip install google_images_download
```
**2.进入下载目录**
```
cd ~/Downloads 
```

**3.执行语句**
```
googleimagesdownload -k "谭卓" -l 20
```
-k 代表“keyword”  -l代表“limit”

+ **出现Could not open URL. Please check your internet connection and/or ssl settings错误时：** 把ss的系统代理模式和代理规则改为全局
+ **出现Looks like we cannot locate the path the 'chromedriver' (use the '--chromedriver' argument to specify the path to the executable.) or google chrome browser is not installed on your machine (exception: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home)错误时：** 首先下载Chromedriver，下载链接在<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">这里</a>,下载后解压，把解压后的那个exe文件复制到要下载的目录下！然后执行：
```
googleimagesdownload -k "郝蕾" -l 200 --chromedriver="./chromedriver"
```
这里 --chromedriver 参数，用来告诉 google-images-download ，解压后 chromedriver 所在路径。

###灰度值和像素值
灰度值就是使rgb三种颜色空间的像素值相等，R=G=B,相等的值就是灰度值。

灰度化的处理方法：在灰度化图像中灰度值的范围是0-255
1. 浮点算法：Gray=R * 0.3+G * 0.59+B * 0.11     R=G=B

2. 整数方法：Gray=(R* 30+G* 59+B* 11)/100    R=G=B

3. 移位方法：Gray =(R* 28+G* 151+B* 77)>>8   R=G=B

4. 平均值法：Gray=（R+G+B）/3             R=G=B

5. 仅取绿色：Gray=G                       R=G=B

二值化处理：
就是让图像的像素点矩阵的每个像素点的灰度值为0或255，这样整幅图像就呈现为只有黑和白的效果。

但是如何确定值呢？ 
1. 第一种方法：以127为阈值，让灰度值小于127的变为0（黑色），大于127的变为255（白色）
2. 第二种方法：计算像素点的平均值avg，然后让每个像素点
的像素值与它比较，小于平均值的像素点就是0（黑色），大于平均值的就是255（白色）
3. 直方图方法

###视频监控中的前景目标检测算法的研究
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/视频监控.jpg)

底层从视频图像采集终端获取图像，然后预处理，对当前场景进行背景建模或者目标建模从而提取感兴趣目标。中层在底层的基础上提取出目标进行跟踪，识别等，高层完成对目标的行为的分析和理解，并根据预设规则输出分析结果。

前景就是你感兴趣的对象，背景不是。例如，要检测传送带上的螺丝钉。螺丝钉就是前景，传送带就是背景。

####帧间差分法
&emsp; 通过相邻帧之间存在强相关性来进行前景目标检测。在连续图像序列的两三个相邻帧之间，其像素值存在大量的相似性，其中只有少部分会发生变化。而这些变化的像素一般被认为是由于目标位置移动引起的。
&emsp; 优点：计算简单，运算复杂度低，能够快速检测出场景中运动的目标。缺点：过于简单导致精度不高，如速度过快情况，在很短的时间内，原来被前景遮挡的部分也显现出来，根据阈值判断这些部分也是前景。


###仿射变换

####线性变换
从几何直观角度看有三个要点：
+ 变换前是直线，变换后依然是直线
+ 直线的比例保持不变
+ 变换前过原点，变换后依然过原点

假设A=[x,y]^T^
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/旋转矩阵.jpg)

总之，线性变换是通过矩阵乘法实现的。

####仿射变换
简单来说就是：线性变换 + 平移
从直观角度只有两个要点：
+ 变换前是直线，变换后依然是直线
+ 直线比例保持不变

例如平移，它是仿射变换。

仿射变换不能光通过矩阵乘法实现，还得有加法。

仿射变换：
$$\vec{y}=A\vec{x}+\vec{b}$$ 
可以写作：
$$
  \left[
  \begin{matrix}
    \vec{y} \\
    1
  \end{matrix}
  \right] = \left[
    \begin{matrix}
      A& \vec{b}\\
      0&1
    \end{matrix}
    \right] \left[
      \begin{matrix}
        \vec{x}\\
        1
      \end{matrix}
      \right]
$$
  
计算这个矩阵相乘可以发现，多了一部分相乘。这相当于增加了一个维度，这样就可以在**高维度** 通过线性变换来完成低维度的仿射变换。



###image.shape[0],image.shape[1]
shape[0]代表垂直像素（height）
shape[1]代表水平像素（width）



####边缘检测
**边缘：** 是指周围的像素灰度急剧变化的那些像素集合，它是图像最基本的特征。
**图像的边缘检测：** 先检测图像的边缘点，在按照某种策略将边缘点连接成轮廓，从而构成分割区域。

####角点检测
角点的两种定义：
1. 角点是两个边缘的角点。
2. 角点是邻域内具有两个主方向的特征点。

前者需要对边缘进行编码，很大程度依赖于图像分割和提取，具有相当大的难度和计算量。且一旦目标的局部发生变化，可能导致操作失败。

角点在保留重要特征的同时，可以有效减少信息的数据量，有效提高计算速度，使得实时称为可能。

目前的角点检测分为三类：
1. 基于灰度图像的角点检测
2. 基于二值图像的角点检测
3. 基于轮廓曲线的角点检测

###可见光谱
是电磁波谱中唯一可见的按照波长从小到大排列而形成的图案。它是电磁波谱中相当窄的一部分。

电磁波谱：伽马射线，x射线，紫外线，红外线，微波，无线电波。

可见光波段跨越范围约为0.43微米（紫色）到0.79微米（红色），分为6个主要区域：紫色，蓝色，绿色，黄色，橘黄色（橙色），红色

###简单的图像形成模型
我们使用形如$f(x,y)$的二维函数来表示图像。它可由两个分量来表征：
1. 入射到被观察场景的光源照射总量，即：入射分量，表示为$i(x,y)$
2. 场景中物体所反射的光照总量。即：反射分量，表示为$r(x,y)$

两个分量的乘积合并形成f(x,y)：
$$f(x,y)=i(x,y)r(x,y)$$
其中：
$$0<i(x,y)<\infty$$ $$0<r(x,y)<1$$



###信噪比
对去噪前后的图像质量进行衡量。即：对一幅含有噪声的图像在进行去噪操作后判断图像质量是否有所提高。

###对比度
对比度是画面黑与白的比值，也就是从黑到白的渐变层次。比值越大，从黑到白的渐变层次越多，从而色彩就越丰富。一般来说，对比度越大，图像越清晰醒目，色彩越鲜明艳丽。

###高斯拟合
一维高斯函数：$$f(x)=ae^{-\cfrac{(x-b)^2}{2c^2}}$$
其中a表示曲线的高度，b指曲线在x轴的中心，c代表半峰全宽（即曲线一半峰值之间的x轴宽度）
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/高斯曲线.jpg)

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/高斯拟合1.jpg)

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/高斯拟合2.jpg)

要进行数据点的高斯分布参数拟合之前，必须确保数据点近似是高斯分布的形态，即近似符合正态分布的规律。

###高频信号和低频信号
亮度或灰度变化剧烈的地方对应高频成分，如边缘，变化不大的地方对应低频成分，如大片色块区。

###自适应对比度增强
人眼对于高频信号往往比较敏感，但是如果高频信号中嵌入了大量低频信号或者噪声信号，则其视觉可见性会降低，此时适当提高高频部分能够得到较好的视觉效果。

ACE原理：将图像分为两部分，一是低频部分，通过低通滤波（虑掉高频信息）获得；二是高频部分，通过原图减去低频部分获得。而算法的目标则是增强代表细节的高频部分，即对高频部分乘以某个增益值，一种方案是乘以一个固定值，另一种是将增益值表示为与方差相关的量。

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/自适应对比度增强.jpg)

###空间分辨率，屏幕分辨率，图像分辨率,灰度分辨率
单个像元（像素）所代表的地面面积。通常来说，空间分辨率也称为像元大小。即一个像素的大小就是**空间分辨率**。

如我们需要呈现一个71平方米的面要素。若采用1米宽的像元，就需要16 * 16个像素，若是4米宽像元，则需要4 * 4个像素，这样连轮廓都看不清。

**屏幕分辨率：是屏幕每行的像素点数*每列的像素点数，每个屏幕有自己的分辨率**

**图像分辨率：指每英寸图像内的像素点数。单位是像素每英寸(Pixels Per Inch，PPI)** 

**灰度分辨率：用于量化灰度的比特数**，例如，通常说一幅被量化为256级的图像有8比特的灰度分辨率。

###像素邻接
**4邻接：** 对于具有值V得像素p和q，如果q在集合N4(p)中，则称这两个像素是4连通的。**（这些像素点的像素值都一致）**

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/4连通.jpg)

**8邻接：** 对于具有值V得像素p和q，如果q在集合N8(p)中，则称这两个像素是8连通的。
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/8连通.jpg)

**m邻接：** 对于具有值V的像素p和q，如果：
1. q在集合N4(p)中，或
2. q在集合ND(p)中，并且N4(p)与N4(q)的交集为空，则称两个像素是m连通的，即4连通和D连通的混合连通。
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/m连通.jpg)

如上图右图所示，p的4邻域和q的4邻域有交集，即右上边的红色方块，故不是m连通，而上图作图，p和q的4邻域没有交集，故是m连通。

m连通是为了消除8连通的二义性。**在通路中体现**

当按照特定的邻接性来确认像素的通路时，必须保证通路的唯一性。如以下的例子：
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/像素通路.jpg)

粉色为p，蓝色为q
从p到q，如果选择8邻接，则通路并不唯一。即从p左上的1，到它上方的1和斜上方的1都是8邻接，所以**具有二义性**

而考虑m邻接时，则通路就是唯一的，即p到斜上方的1是m邻接，而斜上方的1，对于q来讲就不是m邻接，因为它上方有个1，因此考虑m邻接只能走它上方的1，然后再到q，这样通路就唯一了。

###灰度变换
####作用
1. 改善图像的质量，使图像能显示更多的细节，提高图像的对比度
2. 有选择的突出图像感兴趣的特征或者抑制图像中不需要的特征
3. 可以有效的改变图像的直方图分布，使像素分布的更加均匀

####线性变换
令r为变换前的灰度，s为变换后的灰度，则线性变换的函数：$$s = a·r+b$$,其中，a为直线的斜率，b为在y轴的截距，选择不同的a，b值会有不同的效果：
+ a > 1, 增加图像的对比度
+ a < 1, 减小图像的对比度
+ a = 1且$b \neq 0$, 图像整体的灰度值上移或者下移，也就是整体变亮或者变暗，不会改变对比度
+ a < 0且b = 0, 图像的亮区域变暗，暗区域变亮
+ a = -1且b = 255， 图像反转，即255-r

####分段线性变换
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/分段线性1.jpg)
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/分段线性2.jpg)
此时根据r1,s1,r2,s2可分为两种增强情况：
+ r1 <= r2,s1 <= s2:对比度拉伸，增强感兴趣区域
+ r1 = r2,s1=0,s2=L-1:阈值处理，产生一个二值图像

常见对比度拉伸，例如：最大值最小值对比度拉伸：
令：**(r1,s1)=(rmin,0),(r2,s2)=(rmax,L-1),其中rmin，rmax是图像中出现的最小灰度级，最大灰度级，此时将灰度级拉伸到[0,L-1]**

####对数变换
公式：$$s = clog(1+r)$$c是一个常数，![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/对数函数.jpg)由对数曲线可知：**对数变换，将原图像范围较窄的低灰度值映射到范围较宽的灰度区间，同时将范围较宽的高灰度值区间映射为较窄的灰度空间，从而扩展了暗像素的值，压缩了高灰度的值，能够对图像中低灰度细节进行增强。**

**由于对数曲线在像素值较低的地方斜率比较大，在像素值较高的地方斜率较小，因此对数变换可以提升较暗区域的对比度，这种变换可以用于增强暗部细节**

**并且可以合理的压缩图像的动态范围**

**反对数函数（指数函数）则恰恰相反，作用是压缩灰度值较低的区间，扩展高灰度值的区间**

####幂率变换（伽马变换）
公式：$$s = cr^\gamma$$其中c和$\gamma$是正常数。
伽马变换的效果与对数变换类似。
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/伽马变换函数.jpg)
如上图，当$\gamma < 1$时，$\gamma$的值越小，对图像低灰度值的扩展就越明显。反之，对图像高灰度值部分的扩展越明显。

伽马变换主要用于图像的校正，对灰度值过高（图像过亮）或者过低（图像过暗）的图像进行修正，增加图像的对比度，从而改善图像的显示效果。

###散焦
与聚焦相反，散焦的含义就是一束平行于透镜的平行光本来要汇聚到透镜的焦点上，但是凹透镜发散，但发散后的光线的反向延长线会汇集到透镜的焦距位置上。

###掩膜
用于部分或完全隐藏对象或元素的部分的图形操作，效果就好像将图形对象通过遮罩涂在背景上，从而完全或部分的遮盖了图形对象的各个部分，而遮罩内的图像不变化。在图像处理中常用于提取ROI区域
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/掩膜.jpg)

形象的说就是将mask放在原图上，然后在上面刷黑漆，mask区域图像不变，其他区域涂黑了

###HSV,HSI,HLS
HSV(色调，饱和度，纯度)
HSI(色调，饱和度，亮度)
HLS(色调，明度，饱和度)

###线性操作
考虑一般算子H，该算子对于给定的输入图像f(x,y)，产生的一幅输出图像g(x,y):$$H[f(x,y)]=g(x,y)$$如果$$H[a_if_i(x,y)+a_jf_j(x,y)]=a_iH[f_i(x,y)]+a_jH[f_j(x,y)]\\=a_ig_i(x,y)+a_jg_j(x,y)$$则称H为一个线性算子，因为两个输入的和与分别对输入进行操作然后求和得到的结果相同。**（称为加性）**

另外，输入乘以常数的线性操作的输出与乘以该常数的原始输入的操作的输出是相同的。**（称为同质性）**


###直方图均衡化
直方图是这样一个函数：$$h(r_k)=n_k$$其中，r~k~表示的是第k级灰度，n~k~表示的是图像中灰度级为第k级所对应的的像素个数，设n是这幅图像所有像素的总数

实际中往往需要归一化：$$P(r_k)=\cfrac{n_k}{n}$$,k=0,1,2,...,L-1，简单来讲，P(r~k~)其实表达了某种概率的形式。表示该灰度级占总像素个数的比例。

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/直方图1.jpg)
上图代表的直方图，横轴代表各个像素级，纵轴代表个数或者归一化的值。

观察以上四图可以发现：
+ 在较暗的图像中，直方图组成成分集中在灰度级低的一侧
+ 在比较亮的图像中，直方图组成成分集中在灰度级高的一侧
+ 在低对比度的图像中，直方图窄而且集中在中间的区域
+ 在高对比度的图像中，直方图覆盖了灰度级很宽的范围内，并且像素分布比较均匀

**直方图均衡** 就是要使图像的直方图尽可能的覆盖全部可能的灰度级，并且分布均匀，这样图像就获得了高对比度和多变得灰度色调

提高图像对比度的变换函数f(x)需要满足以下条件：
+ f(x)在$0=<x<=L-1$上是单值，并且单调递增,L表示灰度级
+ f(x)的范围是[0,L-1]

当图像直方图均匀分布时，此时图像的熵最大，此时对比度最大。那么找到适合的f(x)就很重要了，这里有一个重要函数：$$y=f(x)=(L-1)\int_0^xp_x(t)dt$$ $p_x(x)$表示概率密度函数，在离散的图像中，表示直方图中每个灰度级的概率。因此它具有两个性质，单调递增，值域为[0,1]

####证明变换后的直方图是均匀的
首先回顾概率知识：
**设已知随机变量X的分布函数为$F_x(x)$和密度函数为$p_x(x)$,又设Y=g(X),其中函数g(·)是严格单调函数，且导数$g'(·)$存在，则Y的密度函数为$$p_Y(y)=p_x(h(y))|h'(y)|$$** 其中h(y)是y=g(x)的反函数
证明：
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/定理证明.jpg)


由上公式可得变换后的概率密度：$$p_y(y)=p_x(x)|(f^{-1}(y))'|$$由变上限函数求导法则可知：$$f(x)'=(L-1)p_x(x)$$反函数的导数等于原函数导数的倒数：$$(f^{-1}(y))'=\cfrac{1}{(L-1)p_x(x)}$$所以$$p_y(y)=\cfrac{1}{L-1}$$因此，变换后的概率密度函数是一个均匀分布。

下面需要将这个变换函数转换为为图像中的表达，在图像中我们可以使用求和代替积分，差分代替微分，所以变换函数变为：$$y=f(x)=(L-1)\sum_0^{x_i}\cfrac{h(x_i)}{w\times h}$$其中$h(x_i)$表示直方图中每个灰度级像素的个数，w和h分别表示图像的宽和高


**缺陷：** 当图像中存在弱小的目标时，经过直方图均衡化后的目标信息经常会被数量占优的像元信息淹没，同时数量占比大的像元容易造成过增强。

####自适应对比度增强（Adaptive histogram equalization,AHE）
普通的HE方法在灰度分布均匀的图像上处理效果还可以，但是到了有高峰的直方图处理后，对比度过分不自然

AHE在这个问题上将计算的范围从整体缩小为局部，即每个像素通过其周围的一个矩形范围的像素直方图进行均衡化，方法同HE

####限制对比度的自适应直方图均衡（CLAHE）
CLAHE通过在计算CDF(累积密度函数)前先用预先定义的阈值来裁剪直方图以达到限制放大幅度的目的。
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/clahe.webp)我们需要对子块中统计得到的直方图进行剪裁，使其幅值低于某个上限，当然剪裁的部分又不能扔掉，我们还需要将剪裁的部分均匀的分布在整个灰度区间上，以保证直方图总面积不变。

###图像增强
分两种：
+ 邻域处理技术（类似卷积核）
+ 点处理技术

###欧拉公式
$$e^{ix}=cosx+isinx$$ $$sinx=\cfrac{e^{ix}-e^{-ix}}{2i}$$ $$cosx=\cfrac{e^{ix}+e^{-ix}}{2}$$
 欧拉公式将正弦波，余弦波统一成了简单指数形式。**（表达式是复数）**

根据复数的表达形式，可以看出乘以i的效果是将数值逆时针旋转了90度，数轴与虚数轴共同构成了复平面。

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/欧拉螺旋.jpg)

欧拉公式所描述的是一个随着时间变化，在复平面上做圆周运动的点，随着时间改变，在时间轴上就成了一条螺旋线，如果只看它的实数部分，也就是螺旋线左侧的投影，就是一个余弦函数，而右侧的投影则是一个正弦函数。

**欧拉公式告诉我们：正弦波的叠加，可以理解为螺旋线的叠加在实数空间的投影。**

###图像平均
图像有噪声时，要去噪可以采用图像平均。在一个像素点的8邻域内，将这9个像素点的值取平均，然后作为这个点的新值。

###频谱
一个余弦信号的全部信息可以由频率。幅度和初相位三参数来确定。而一个复杂信号是由多个余弦信号（余弦减去90度就是正弦信号）叠加而成的。

因此，信号的频谱就是表示一个复杂信号的所有不同频率的余弦信号的三参数信息。反过来，通过频谱可以知道这个复杂信号包含哪些频率的余弦信号，以及信号的幅度和初相位。

###傅里叶相关
####傅里叶级数
产生过程：
1. 把一个周期函数f(t)通过最简单的一系列正弦函数表示，如：$$f(t)=A_0 + \sum_{n=1}^\infty A_nsin(n\omega t+\psi_n)$$
2. 通过变形后用三角级数来表示，例如可以将上式sin函数展开。即：$$f(t)=A_0+\sum_{n=1}^\infty[a_ncos(n\omega t)+b_nsin(n\omega t)]$$
3. 通过积分，把各未知系数用f(t)的积分式来表达。首先，对等式两边取$[-\pi,\pi]$（假设周期是2pi）的积分，可以解得A~0~的值。令$a_0=2A_0$,解得$$a_0=\cfrac{2}{T}\int_{t_0}^{t_0+T}f(t)dt$$,然后等式两端分别乘以$cos(k\omega t)，sin(k\omega t)$,解得$$a_n=\cfrac{2}{T}\int_{t_0}^{t_0+T}f(t)cos(n\omega t)dt$$ $$b_n=\cfrac{2}{T}\int_{t_0}^{t_0+T}f(t)sin(n\omega t)dt$$
4. 求得的这些表达式就是傅里叶级数公式

详细见：<a href="https://zhuanlan.zhihu.com/p/41455378">傅里叶级数推导</a>

###霍夫变换
基本原理是在于利用点与线的对偶性，将原始图像的给定曲线变为在参数空间的一个点，如：在直角坐标系下的一条直线，可在极坐标系中变为一个点。

####直线检测
假设在直角坐标系下直线的方程为：$y=k\times x+b$,其中k，b是参数（斜率和截距），过某一点(x0,y0)会满足等式$y_0=k\times x_0+b$,这在k-b坐标系下可以表示为一条直线。

因此，原坐标系下的整条直线，在新的参数坐标系下，表示为过一点的所有直线。（因为原坐标系下的一条直线，它的k和b是确定的，因此原直线的每一点，在参数坐标系下所对应的直线都经过(k,b)这个点，故它们相交于一点）

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/参数坐标系.jpg)

因此，在原坐标系下直线的所有点投影到参数坐标系下后，看参数坐标系是否有聚集点，这样的聚集点对应了原始坐标系下的直线。

但是实际应用中，在直角坐标系下，无法使用$y=k\times x+b$这样的公式来表示x=c形式的直线（此时，斜率为无穷大），因此采用参数方程$$p=xcos\theta+ysin\theta$$来表示直线,这样原图像的一个点就对应了$p-\theta$坐标系下的一条曲线。因为对原图像的一个点来说，x，y是确定的，因此该方程就变成了三角函数，通过辅助角公式等可以变换成为正弦或余弦函数。如下图c所示：
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/参数坐标系2.jpg)

因此原直线的每个点，对应参数坐标系的每条曲线，因此问题转化为$p-\theta$坐标系的多条曲线是否交于一点。

![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/参数坐标系3.jpg)

具体的做法如上图：将坐标系分为许多个小方格，每个直线都会落在多个相应的小格中，并把相应的小格计数加1。

但是对于交点来说，在包含交点的小格的数值一定是最大的（因为理论上每条曲线都会经过该小格），最后通过该小格的坐标来确定（$\theta$,p），也就确定了原坐标系的该直线。

####霍夫变换两点为什么乘1000
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/霍夫变换两点为什么乘1000.jpg)

如图，根据$(p,\theta)$可以先求出(x0,y0)坐标，为了确定直线两头的坐标，把1000设置为点x0到x1，x2的直线距离（这样x1就等于x0的坐标-1000*cos(90-$\theta$)，相当于减去1000\*sin$\theta$）,故求得x1，x2的坐标，因此可以画出直线。