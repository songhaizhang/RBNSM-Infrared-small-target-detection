###解释型语言和编译型语言
计算机是不能够识别高级语言的，所以当我们运行一个高级语言程序的时候，就需要一个“翻译机”来从事把高级语言转变成计算机能读懂的机器语言的过程。这个过程分成两类，第一种是编译，第二种是解释。

编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序转变成机器语言。运行时就不需要翻译，而直接执行就可以了。最典型的例子就是C语言。

解释型语言就没有这个编译的过程，而是在程序运行的时候，通过解释器对程序逐行作出解释，然后直接运行，最典型的例子是Ruby。

通过以上的例子，我们可以来总结一下解释型语言和编译型语言的优缺点，因为编译型语言在程序运行之前就已经对程序做出了“翻译”，所以在运行时就少掉了“翻译”的过程，所以效率比较高。但是我们也不能一概而论，一些解释型语言也可以通过解释器的优化来在对程序做出翻译时对整个程序做出优化，从而在效率上超过编译型语言。

此外，随着Java等基于虚拟机的语言的兴起，我们又不能把语言纯粹地分成解释型和编译型这两种。

用Java来举例，Java首先是通过编译器编译成字节码文件，然后在运行时通过解释器给解释成机器文件。所以我们说Java是一种先编译后解释的语言。

再换成C#，C#首先是通过编译器将C#文件编译成IL文件，然后在通过CLR将IL文件编译成机器文件。所以我们说C#是一门纯编译语言，但是C#是一门需要二次编译的语言。同理也可等效运用到基于.NET平台上的其他语言。
###pyhton是一门先编译后解释的语言和java一致

###简述python运行过程
在说这个问题之前，我们先来说两个概念，PyCodeObject和pyc文件。

我们在硬盘上看到的pyc自然不必多说，而其实PyCodeObject则是Python编译器真正编译成的结果。我们先简单知道就可以了，继续向下看。

当python程序运行时，编译的结果则是保存在位于内存中的PyCodeObject中，当Python程序运行结束时，Python解释器则将PyCodeObject写回到pyc文件中。

当python程序第二次运行时，首先程序会在硬盘中寻找pyc文件，如果找到，则直接载入，否则就重复上面的过程。

所以我们应该这样来定位PyCodeObject和pyc文件，我们说pyc文件其实是PyCodeObject的一种持久化保存方式。

###安卓studio syso可输出
>Editor>Live Templates>output中添加一个项，选择第一个Live Template
![](https://raw.githubusercontent.com/nanfengchuiyeluo6/images/master/%E8%B0%83%E5%87%BAsyso.png)

###关于影响因子
IF计算方式是**sci期刊在前两年发表的论文在该年的总被引次数除以该期刊在前两年发表的论文总数**

例：以SCI期刊《自然》（Nature）为例说明之：
2013年Nature发表的论文在2015年的被引次数为34618次；
2014年Nature发表的论文在2015年的被引次数为31056次；
2013~2014年Nature发表的论文在2015年的总被引次数为65674次；
2013年Nature发表的论文数量为860篇；
2014年Nature发表的论文数量为862篇；
2013~2014年Nature发表的论文总数为1722篇；
2015年Nature的IF为65674÷1722 = 38.138。
因此，2013年~2014年发表在Nature上的每篇论文在2015年平均被引38.138次


